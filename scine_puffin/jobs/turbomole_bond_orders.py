# -*- coding: utf-8 -*-
from __future__ import annotations
__copyright__ = """ This code is licensed under the 3-clause BSD license.
Copyright ETH Zurich, Department of Chemistry and Applied Biosciences, Reiher Group.
See LICENSE.txt for details.
"""

from typing import TYPE_CHECKING, List
import os

import numpy as np

from scine_puffin.config import Configuration
from .templates.job import calculation_context, job_configuration_wrapper
from .templates.turbomole_job import TurbomoleJob
from .turbomole_single_point import TurbomoleSinglePoint
from ..utilities.turbomole_helper import TurbomoleHelper
from scine_puffin.utilities.imports import module_exists, MissingDependency

if module_exists("scine_database") or TYPE_CHECKING:
    import scine_database as db
else:
    db = MissingDependency("scine_database")


class TurbomoleBondOrders(TurbomoleJob):

    """
    A job generating Wiberg bond orders and derived data for a single structure.

    **Order Name**
      ``turbomole_bond_orders``

    **Optional Settings**
      Optional settings are read from the ``settings`` field, which is part of
      any ``Calculation`` stored in a SCINE Database.
      Possible settings for this job are:

     All settings that are recognized by the turbomole_single_point job.

    **Required Packages**
      - SCINE: Database (present by default)
      - SCINE: Utils (present by default)
      - The Turbomole program has to be available

    **Generated Data**
      If successful the following data will be generated and added to the
      database:

      Properties
        The ``bond_orders`` and the ``electronic_energy`` associated with the structure.
    """

    def __init__(self) -> None:
        super().__init__()
        self.input_structure = "system.xyz"
        self.bond_orders_input_file = "bond_orders.inp"
        self.bond_orders_output_file = "proper.out"
        self.tm_helper = TurbomoleHelper()
        self.tm_single_point = TurbomoleSinglePoint()

    def get_bond_orders(self, natoms: int) -> np.ndarray:
        """
        Read Wiberg bond orders from file generated by the 'proper' postprocessing tool
        """

        bond_orders = np.zeros((natoms, natoms))
        with open(self.bond_orders_input_file, "a") as bond_orders_file:
            bond_orders_file.write("pop\nwiberg\nend\nend\n")

        self.tm_helper.execute(
            os.path.join(self.tm_helper.turbomole_job.turboexe, "proper"),
            input_file=self.bond_orders_input_file,
            error_test=True,
            stdout_tofile=True,
        )

        with open(self.bond_orders_output_file, "r") as file:
            lines = file.readlines()
            for index, line in enumerate(lines):
                if "Number of electrons" in line:
                    current_line_index = index
                    # Go forward until bond orders start
                    while "\n" not in lines[current_line_index]:
                        current_line_index += 1
                    current_line_index += 1
                    # Add the bond orders to the list until empty line
                    while lines[current_line_index].strip():
                        first_atom_index = lines[current_line_index].split()[1]
                        second_atom_index = lines[current_line_index].split()[4]
                        if first_atom_index.isdigit() and second_atom_index.isdigit():
                            bond_order = float(lines[current_line_index].split()[5])
                            at1 = int(first_atom_index)
                            at2 = int(second_atom_index)
                            current_line_index += 1
                            bond_orders[at1 - 1][at2 - 1] = bond_order
                            bond_orders[at2 - 1][at1 - 1] = bond_orders[at1 - 1][at2 - 1]
                        else:
                            raise ValueError("Something went wrong while parsing Turbomole bond orders.")
        return bond_orders

    @job_configuration_wrapper
    def run(self, manager: db.Manager, calculation: db.Calculation, config: Configuration) -> bool:

        # Gather all required collections
        structures = manager.get_collection("structures")
        calculations = manager.get_collection("calculations")
        properties = manager.get_collection("properties")

        # Link calculation if needed
        if not calculation.has_link():
            calculation.link(calculations)

        # Get structure
        structure = db.Structure(calculation.get_structures()[0])
        structure.link(structures)
        natoms = len(structure.get_atoms())

        # Get model
        model = calculation.get_model()

        # Get job
        job = calculation.get_job()

        if not self.turboexe:
            calculation.set_status(db.Status.FAILED)
            raise RuntimeError("Turbomole executables are not available.")

        calculation_settings = calculation.get_settings()
        # Do calculation
        with calculation_context(self):
            # Prepare calculation
            self.prepare_calculation(structure, calculation_settings, model, job)
            # Execute single_point necessary for subsequent hessian calculation
            self.tm_single_point.execute_single_point_calculation(job)
            # Parse output file
            parsed_energy = self.tm_helper.parse_energy_file()
            # Parse bond orders
            bond_orders = self.get_bond_orders(natoms)
            spin_mode = self.tm_helper.evaluate_spin_mode(calculation_settings)

        # After the calculation, verify that the connection to the database still exists
        self.verify_connection()

        # Capture raw output
        stdout_path = os.path.join(self.work_dir, "output")
        stderr_path = os.path.join(self.work_dir, "errors")
        with open(stdout_path, "r") as stdout, open(stderr_path, "r") as stderr:
            error = stderr.read()
            calculation.set_raw_output(stdout.read() + "\n" + error)

        if not os.path.exists(os.path.join(self.work_dir, "success")):
            if len(error.strip()) > 0:
                calculation.set_comment(error.replace("\n", " "))
            else:
                calculation.set_comment(
                    "Bond Order Job Error: Turbomole Bond Order job failed with an unspecified error."
                )
            calculation.set_status(db.Status.FAILED)
            return False

        # Update model
        model.program = "turbomole"
        model.spin_mode = spin_mode
        model.version = config.programs()[model.program]["version"]
        calculation.set_model(model)

        # Generate database results
        db_results = calculation.get_results()
        db_results.clear()
        calculation.set_results(db_results)

        # Store energy
        self.store_property(
            properties,
            "electronic_energy",
            "NumberProperty",
            parsed_energy,
            model,
            calculation,
            structure,
        )
        # Store hessian
        self.store_property(
            properties,
            "bond_orders",
            "SparseMatrixProperty",
            bond_orders,
            model,
            calculation,
            structure,
        )
        calculation.set_status(db.Status.COMPLETE)
        return True

    @staticmethod
    def required_programs() -> List[str]:
        return ["database", "utils", "turbomole"]
